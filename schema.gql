# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AggregatePost {
  count: Int
  max: PostMaxAggregate
  min: PostMinAggregate
}

type AggregateUpvote {
  count: Int
  max: UpvoteMaxAggregate
  min: UpvoteMinAggregate
}

type AggregateUser {
  count: Int
  max: UserMaxAggregate
  min: UserMinAggregate
}

type BatchPayload {
  count: Int!
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

type Mutation {
  createPost(data: PostCreateInput!): Post!
  createUpvote(data: UpvoteCreateInput!): Upvote!
  createUser(data: UserCreateInput!): User!
  deleteManyPost(where: PostWhereInput): BatchPayload!
  deleteManyUpvote(where: UpvoteWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteUpvote(where: UpvoteWhereUniqueInput!): Upvote
  deleteUser(where: UserWhereUniqueInput!): User
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  updateManyUpvote(data: UpvoteUpdateManyMutationInput!, where: UpvoteWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateUpvote(data: UpvoteUpdateInput!, where: UpvoteWhereUniqueInput!): Upvote
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertPost(create: PostCreateInput!, update: PostUpdateInput!, where: PostWhereUniqueInput!): Post!
  upsertUpvote(create: UpvoteCreateInput!, update: UpvoteUpdateInput!, where: UpvoteWhereUniqueInput!): Upvote!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Post {
  createdAt: DateTime!
  editor: User
  id: String!
  parent: Post
  postId: String
  replies(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]
  updatedAt: DateTime!
  upvotes(cursor: UpvoteWhereUniqueInput, distinct: [UpvoteScalarFieldEnum!], orderBy: [UpvoteOrderByInput!], skip: Int, take: Int, where: UpvoteWhereInput): [Upvote!]
  userId: String
}

input PostCreateInput {
  createdAt: DateTime
  editor: UserCreateOneWithoutPostsInput
  id: String
  parent: PostCreateOneWithoutRepliesInput
  replies: PostCreateManyWithoutParentInput
  updatedAt: DateTime
  upvotes: UpvoteCreateManyWithoutPostInput
}

input PostCreateManyWithoutEditorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithouteditorInput!]
  create: [PostCreateWithoutEditorInput!]
}

input PostCreateManyWithoutParentInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutparentInput!]
  create: [PostCreateWithoutParentInput!]
}

input PostCreateManyWithoutUpvotesInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutupvotesInput!]
  create: [PostCreateWithoutUpvotesInput!]
}

input PostCreateOneWithoutRepliesInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutrepliesInput
  create: PostCreateWithoutRepliesInput
}

input PostCreateOrConnectWithouteditorInput {
  create: PostCreateWithoutEditorInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithoutparentInput {
  create: PostCreateWithoutParentInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithoutrepliesInput {
  create: PostCreateWithoutRepliesInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithoutupvotesInput {
  create: PostCreateWithoutUpvotesInput!
  where: PostWhereUniqueInput!
}

input PostCreateWithoutEditorInput {
  createdAt: DateTime
  id: String
  parent: PostCreateOneWithoutRepliesInput
  replies: PostCreateManyWithoutParentInput
  updatedAt: DateTime
  upvotes: UpvoteCreateManyWithoutPostInput
}

input PostCreateWithoutParentInput {
  createdAt: DateTime
  editor: UserCreateOneWithoutPostsInput
  id: String
  replies: PostCreateManyWithoutParentInput
  updatedAt: DateTime
  upvotes: UpvoteCreateManyWithoutPostInput
}

input PostCreateWithoutRepliesInput {
  createdAt: DateTime
  editor: UserCreateOneWithoutPostsInput
  id: String
  parent: PostCreateOneWithoutRepliesInput
  updatedAt: DateTime
  upvotes: UpvoteCreateManyWithoutPostInput
}

input PostCreateWithoutUpvotesInput {
  createdAt: DateTime
  editor: UserCreateOneWithoutPostsInput
  id: String
  parent: PostCreateOneWithoutRepliesInput
  replies: PostCreateManyWithoutParentInput
  updatedAt: DateTime
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

type PostMaxAggregate {
  createdAt: DateTime
  id: String
  postId: String
  updatedAt: DateTime
  userId: String
}

type PostMinAggregate {
  createdAt: DateTime
  id: String
  postId: String
  updatedAt: DateTime
  userId: String
}

input PostOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostRelationFilter {
  is: PostWhereInput
  isNot: PostWhereInput
}

enum PostScalarFieldEnum {
  createdAt
  id
  postId
  updatedAt
  userId
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  postId: StringNullableFilter
  updatedAt: DateTimeFilter
  userId: StringNullableFilter
}

input PostUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  editor: UserUpdateOneWithoutPostsInput
  id: StringFieldUpdateOperationsInput
  parent: PostUpdateOneWithoutRepliesInput
  replies: PostUpdateManyWithoutParentInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  upvotes: UpvoteUpdateManyWithoutPostInput
}

input PostUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateManyWithoutEditorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithouteditorInput!]
  create: [PostCreateWithoutEditorInput!]
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutEditorInput!]
  updateMany: [PostUpdateManyWithWhereWithoutEditorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutEditorInput!]
}

input PostUpdateManyWithoutParentInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutparentInput!]
  create: [PostCreateWithoutParentInput!]
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutParentInput!]
  updateMany: [PostUpdateManyWithWhereWithoutParentInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutParentInput!]
}

input PostUpdateManyWithoutUpvotesInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutupvotesInput!]
  create: [PostCreateWithoutUpvotesInput!]
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutUpvotesInput!]
  updateMany: [PostUpdateManyWithWhereWithoutUpvotesInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutUpvotesInput!]
}

input PostUpdateManyWithWhereWithoutEditorInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithWhereWithoutParentInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithWhereWithoutUpvotesInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateOneWithoutRepliesInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutrepliesInput
  create: PostCreateWithoutRepliesInput
  delete: Boolean
  disconnect: Boolean
  update: PostUpdateWithoutRepliesInput
  upsert: PostUpsertWithoutRepliesInput
}

input PostUpdateWithoutEditorInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  parent: PostUpdateOneWithoutRepliesInput
  replies: PostUpdateManyWithoutParentInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  upvotes: UpvoteUpdateManyWithoutPostInput
}

input PostUpdateWithoutParentInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  editor: UserUpdateOneWithoutPostsInput
  id: StringFieldUpdateOperationsInput
  replies: PostUpdateManyWithoutParentInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  upvotes: UpvoteUpdateManyWithoutPostInput
}

input PostUpdateWithoutRepliesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  editor: UserUpdateOneWithoutPostsInput
  id: StringFieldUpdateOperationsInput
  parent: PostUpdateOneWithoutRepliesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  upvotes: UpvoteUpdateManyWithoutPostInput
}

input PostUpdateWithoutUpvotesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  editor: UserUpdateOneWithoutPostsInput
  id: StringFieldUpdateOperationsInput
  parent: PostUpdateOneWithoutRepliesInput
  replies: PostUpdateManyWithoutParentInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateWithWhereUniqueWithoutEditorInput {
  data: PostUpdateWithoutEditorInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithWhereUniqueWithoutParentInput {
  data: PostUpdateWithoutParentInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithWhereUniqueWithoutUpvotesInput {
  data: PostUpdateWithoutUpvotesInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithoutRepliesInput {
  create: PostCreateWithoutRepliesInput!
  update: PostUpdateWithoutRepliesInput!
}

input PostUpsertWithWhereUniqueWithoutEditorInput {
  create: PostCreateWithoutEditorInput!
  update: PostUpdateWithoutEditorInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithWhereUniqueWithoutParentInput {
  create: PostCreateWithoutParentInput!
  update: PostUpdateWithoutParentInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithWhereUniqueWithoutUpvotesInput {
  create: PostCreateWithoutUpvotesInput!
  update: PostUpdateWithoutUpvotesInput!
  where: PostWhereUniqueInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  createdAt: DateTimeFilter
  editor: UserRelationFilter
  id: StringFilter
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  parent: PostRelationFilter
  postId: StringNullableFilter
  replies: PostListRelationFilter
  updatedAt: DateTimeFilter
  upvotes: UpvoteListRelationFilter
  userId: StringNullableFilter
}

input PostWhereUniqueInput {
  id: String
}

type Query {
  aggregatePost(cursor: PostWhereUniqueInput, orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): AggregatePost!
  aggregateUpvote(cursor: UpvoteWhereUniqueInput, orderBy: [UpvoteOrderByInput!], skip: Int, take: Int, where: UpvoteWhereInput): AggregateUpvote!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  findFirstPost(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): Post
  findFirstUpvote(cursor: UpvoteWhereUniqueInput, distinct: [UpvoteScalarFieldEnum!], orderBy: [UpvoteOrderByInput!], skip: Int, take: Int, where: UpvoteWhereInput): Upvote
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): User
  post(where: PostWhereUniqueInput!): Post
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  upvote(where: UpvoteWhereUniqueInput!): Upvote
  upvotes(cursor: UpvoteWhereUniqueInput, distinct: [UpvoteScalarFieldEnum!], orderBy: [UpvoteOrderByInput!], skip: Int, take: Int, where: UpvoteWhereInput): [Upvote!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Upvote {
  createdAt: DateTime!
  id: String!
  post(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]
  updatedAt: DateTime!
  upvoter: User!
  userId: String!
}

input UpvoteCreateInput {
  createdAt: DateTime
  id: String
  post: PostCreateManyWithoutUpvotesInput
  updatedAt: DateTime
  upvoter: UserCreateOneWithoutUpvotesInput!
}

input UpvoteCreateManyWithoutPostInput {
  connect: [UpvoteWhereUniqueInput!]
  connectOrCreate: [UpvoteCreateOrConnectWithoutpostInput!]
  create: [UpvoteCreateWithoutPostInput!]
}

input UpvoteCreateManyWithoutUpvoterInput {
  connect: [UpvoteWhereUniqueInput!]
  connectOrCreate: [UpvoteCreateOrConnectWithoutupvoterInput!]
  create: [UpvoteCreateWithoutUpvoterInput!]
}

input UpvoteCreateOrConnectWithoutpostInput {
  create: UpvoteCreateWithoutPostInput!
  where: UpvoteWhereUniqueInput!
}

input UpvoteCreateOrConnectWithoutupvoterInput {
  create: UpvoteCreateWithoutUpvoterInput!
  where: UpvoteWhereUniqueInput!
}

input UpvoteCreateWithoutPostInput {
  createdAt: DateTime
  id: String
  updatedAt: DateTime
  upvoter: UserCreateOneWithoutUpvotesInput!
}

input UpvoteCreateWithoutUpvoterInput {
  createdAt: DateTime
  id: String
  post: PostCreateManyWithoutUpvotesInput
  updatedAt: DateTime
}

input UpvoteListRelationFilter {
  every: UpvoteWhereInput
  none: UpvoteWhereInput
  some: UpvoteWhereInput
}

type UpvoteMaxAggregate {
  createdAt: DateTime
  id: String
  updatedAt: DateTime
  userId: String
}

type UpvoteMinAggregate {
  createdAt: DateTime
  id: String
  updatedAt: DateTime
  userId: String
}

input UpvoteOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

enum UpvoteScalarFieldEnum {
  createdAt
  id
  updatedAt
  userId
}

input UpvoteScalarWhereInput {
  AND: [UpvoteScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [UpvoteScalarWhereInput!]
  OR: [UpvoteScalarWhereInput!]
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input UpvoteUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  post: PostUpdateManyWithoutUpvotesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  upvoter: UserUpdateOneRequiredWithoutUpvotesInput
}

input UpvoteUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UpvoteUpdateManyWithoutPostInput {
  connect: [UpvoteWhereUniqueInput!]
  connectOrCreate: [UpvoteCreateOrConnectWithoutpostInput!]
  create: [UpvoteCreateWithoutPostInput!]
  delete: [UpvoteWhereUniqueInput!]
  deleteMany: [UpvoteScalarWhereInput!]
  disconnect: [UpvoteWhereUniqueInput!]
  set: [UpvoteWhereUniqueInput!]
  update: [UpvoteUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [UpvoteUpdateManyWithWhereWithoutPostInput!]
  upsert: [UpvoteUpsertWithWhereUniqueWithoutPostInput!]
}

input UpvoteUpdateManyWithoutUpvoterInput {
  connect: [UpvoteWhereUniqueInput!]
  connectOrCreate: [UpvoteCreateOrConnectWithoutupvoterInput!]
  create: [UpvoteCreateWithoutUpvoterInput!]
  delete: [UpvoteWhereUniqueInput!]
  deleteMany: [UpvoteScalarWhereInput!]
  disconnect: [UpvoteWhereUniqueInput!]
  set: [UpvoteWhereUniqueInput!]
  update: [UpvoteUpdateWithWhereUniqueWithoutUpvoterInput!]
  updateMany: [UpvoteUpdateManyWithWhereWithoutUpvoterInput!]
  upsert: [UpvoteUpsertWithWhereUniqueWithoutUpvoterInput!]
}

input UpvoteUpdateManyWithWhereWithoutPostInput {
  data: UpvoteUpdateManyMutationInput!
  where: UpvoteScalarWhereInput!
}

input UpvoteUpdateManyWithWhereWithoutUpvoterInput {
  data: UpvoteUpdateManyMutationInput!
  where: UpvoteScalarWhereInput!
}

input UpvoteUpdateWithoutPostInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  upvoter: UserUpdateOneRequiredWithoutUpvotesInput
}

input UpvoteUpdateWithoutUpvoterInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  post: PostUpdateManyWithoutUpvotesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UpvoteUpdateWithWhereUniqueWithoutPostInput {
  data: UpvoteUpdateWithoutPostInput!
  where: UpvoteWhereUniqueInput!
}

input UpvoteUpdateWithWhereUniqueWithoutUpvoterInput {
  data: UpvoteUpdateWithoutUpvoterInput!
  where: UpvoteWhereUniqueInput!
}

input UpvoteUpsertWithWhereUniqueWithoutPostInput {
  create: UpvoteCreateWithoutPostInput!
  update: UpvoteUpdateWithoutPostInput!
  where: UpvoteWhereUniqueInput!
}

input UpvoteUpsertWithWhereUniqueWithoutUpvoterInput {
  create: UpvoteCreateWithoutUpvoterInput!
  update: UpvoteUpdateWithoutUpvoterInput!
  where: UpvoteWhereUniqueInput!
}

input UpvoteWhereInput {
  AND: [UpvoteWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [UpvoteWhereInput!]
  OR: [UpvoteWhereInput!]
  post: PostListRelationFilter
  updatedAt: DateTimeFilter
  upvoter: UserRelationFilter
  userId: StringFilter
}

input UpvoteWhereUniqueInput {
  id: String
}

type User {
  createdAt: DateTime!
  displayName: String!
  email: String!
  firstName: String
  id: String!
  lastName: String
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]
  updatedAt: DateTime!
  upvotes(cursor: UpvoteWhereUniqueInput, distinct: [UpvoteScalarFieldEnum!], orderBy: [UpvoteOrderByInput!], skip: Int, take: Int, where: UpvoteWhereInput): [Upvote!]
}

input UserCreateInput {
  createdAt: DateTime
  displayName: String!
  email: String!
  firstName: String
  id: String
  lastName: String
  posts: PostCreateManyWithoutEditorInput
  updatedAt: DateTime
  upvotes: UpvoteCreateManyWithoutUpvoterInput
}

input UserCreateOneWithoutPostsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutpostsInput
  create: UserCreateWithoutPostsInput
}

input UserCreateOneWithoutUpvotesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutupvotesInput
  create: UserCreateWithoutUpvotesInput
}

input UserCreateOrConnectWithoutpostsInput {
  create: UserCreateWithoutPostsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutupvotesInput {
  create: UserCreateWithoutUpvotesInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutPostsInput {
  createdAt: DateTime
  displayName: String!
  email: String!
  firstName: String
  id: String
  lastName: String
  updatedAt: DateTime
  upvotes: UpvoteCreateManyWithoutUpvoterInput
}

input UserCreateWithoutUpvotesInput {
  createdAt: DateTime
  displayName: String!
  email: String!
  firstName: String
  id: String
  lastName: String
  posts: PostCreateManyWithoutEditorInput
  updatedAt: DateTime
}

type UserMaxAggregate {
  createdAt: DateTime
  displayName: String
  email: String
  firstName: String
  id: String
  lastName: String
  updatedAt: DateTime
}

type UserMinAggregate {
  createdAt: DateTime
  displayName: String
  email: String
  firstName: String
  id: String
  lastName: String
  updatedAt: DateTime
}

input UserOrderByInput {
  createdAt: SortOrder
  displayName: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  displayName
  email
  firstName
  id
  lastName
  updatedAt
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  displayName: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutEditorInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  upvotes: UpvoteUpdateManyWithoutUpvoterInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  displayName: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutUpvotesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutupvotesInput
  create: UserCreateWithoutUpvotesInput
  update: UserUpdateWithoutUpvotesInput
  upsert: UserUpsertWithoutUpvotesInput
}

input UserUpdateOneWithoutPostsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutpostsInput
  create: UserCreateWithoutPostsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutPostsInput
  upsert: UserUpsertWithoutPostsInput
}

input UserUpdateWithoutPostsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  displayName: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  upvotes: UpvoteUpdateManyWithoutUpvoterInput
}

input UserUpdateWithoutUpvotesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  displayName: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutEditorInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutPostsInput {
  create: UserCreateWithoutPostsInput!
  update: UserUpdateWithoutPostsInput!
}

input UserUpsertWithoutUpvotesInput {
  create: UserCreateWithoutUpvotesInput!
  update: UserUpdateWithoutUpvotesInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  displayName: StringFilter
  email: StringFilter
  firstName: StringNullableFilter
  id: StringFilter
  lastName: StringNullableFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  posts: PostListRelationFilter
  updatedAt: DateTimeFilter
  upvotes: UpvoteListRelationFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}
